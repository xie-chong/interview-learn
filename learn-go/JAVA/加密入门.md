# <p align="center">加密入门</p>

- [1 | 凯撒密码](#1)   
- [2 | 对称加密](#2)
  - [2.1 DES](#2.1)   
  - [2.2 AES](#2.2)   
- [3 | 非对称加密](#3)   
  - [3.1 RSA](#3.1)   



---
---
---
<h1 id="1">1 | 凯撒密码</h1>

---

凯撒： 跟将军进行通信        信件       容易被敌军截获

明文：  原始信息
密文：  经过加密算法混淆之后的信息
abc  -->（加密规则：在字母表上向右移动3位）   def
love  --> oryh

暴力破解法：  穷举法
a (b~z)     key = 1~25 前提： 知道密文用的算法是凯撒密码

频率分析法：（英文中字母e出现的频率最高）

可以编写一段代码来统计一篇文章里面字母出现的频率（样本容量要充分）
假设字母h出现的频率最高 h -> e , 就可以推测出偏移量key


**CaesarDemo.java**   
```
package com.xiechong.encrypt;

public class CaesarDemo {
    public static void main(String[] args) {
        // 1. 明文：原始信息
        String clearText = "heima";
        // 加密规则，将字母按字母表的顺序向右移动3位
        int key = 3;
        String cipher = encrypt(clearText, key);
        System.out.println(cipher);// khlpd

        // 解密规则，将字母按字母表的顺序向左移动3位
        String clear = decrypt(cipher, key);
        System.out.println(clear);
    }

    private static String encrypt(String clearText, int key) {
        char[] charArray = clearText.toCharArray();
        for (int i = 0; i < charArray.length; i++) {
            // 去除每一个字母，并且向右移动key位
            // ASCII码表a（97） A（65）
//            char c = (char) (charArray[i] + key);
//            // 将移动后的字符替换原来的字母
//            charArray[i] = c;

            charArray[i] += key;
        }
        return new String(charArray);
    }


    private static String decrypt(String cipherText, int key) {
        char[] charArray = cipherText.toCharArray();
        for (int i = 0; i < charArray.length; i++) {
            charArray[i] -= key;
        }
        return new String(charArray);
    }
}

```




---
<h1 id="2">2 | 对称加密</h1>

---


**对比**

| 分组（块）加密标准  | 分组大小  |  密钥长度 |
| ------------ | ------------ | ------------ | ------------ |
| DES  | 64 bit = 8 byte  |  56 bit = 7 byte |
| 3DES  | 64 bit = 8 byte  | 168 bit = 21 byte  |
| AES  |  128 bit = 16 byte |  128/192/256 bit = 16/24/32 byte |





---
<h2 id="2.1">2.1 DES</h2>

---

### 1. 概述
加密解密都是使用同一把钥匙。这种加密方法称为对称加密，也称为单密钥加密

凯撒密码就属于对称加密，它的字符偏移量即为密钥。

基于”对称密钥“的加密算法组要有DES算法，3DES算法，AES算法，Blowfish算法，RC5算法和IDEA算法等等。我们
主要介绍的是DES算法和AES算法。

### 2. 对称密码常用的数学运算

* 移位和循环移位
* 置换
* 扩展
* 压缩
* 异或
* 迭代

**总结**：这些运算主要是对比特位进行操作，其共同目的就是把被加密的明文数码尽可能深入的打乱，从而加大破译难度。


**DesDemo.java**   
```
package com.xiechong.encrypt;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class DesDemo {
    public static void main(String[] args) throws Exception {
        // 1. 明文
        // 2. 提供原始密钥：长度64位，8字节
        String clearText = "heinma你好";
        String originKey = "123456789";
        String cipherText = desEncrypt(clearText, originKey);
        System.out.println(cipherText);
        String desDeCryptText = desDecrypt(cipherText, originKey);
        System.out.println(desDeCryptText);
    }

    private static String desDecrypt(String cipherText, String originKey) throws InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher = Cipher.getInstance("DES");
        SecretKeySpec key = getKeyLimitLength(originKey);
        cipher.init(Cipher.DECRYPT_MODE, key);

        byte[] deCode = Base64.getDecoder().decode(cipherText);
        byte[] doFinal = cipher.doFinal(deCode);

        return new String(doFinal);
    }

    /**
     * DES 加密
     *
     * @param clearText
     * @param originKey
     * @return
     * @throws NoSuchPaddingException    // 填充异常（工作模式和填充模式）
     * @throws NoSuchAlgorithmException  // 没有此算法异常
     * @throws InvalidKeyException       // 无效的密钥异常
     * @throws BadPaddingException
     * @throws IllegalBlockSizeException 加密运算：就是通过对比特位进行一些数学运算
     */
    private static String desEncrypt(String clearText, String originKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        // 1. 获取加密算法工具类对象
        Cipher cipher = Cipher.getInstance("DES");
        // 2. 对加密工具类对象进行初始化
        // mode: 加密/解密模式
        // key: 对原始密钥处理之后的密钥
//        SecretKeySpec key = getKey(originKey);
        SecretKeySpec key = getKeyLimitLength(originKey);
        cipher.init(Cipher.ENCRYPT_MODE, key);

        // 3. 用加密工具类对象对明文进行加密-> 密文
        byte[] doFinal = cipher.doFinal(clearText.getBytes());

//        return new String(doFinal);// 乱码

        // 使用base64来解决乱码问题
        byte[] base64StrEn = Base64.getEncoder().encode(doFinal);
        return new String(base64StrEn);
    }

    private static SecretKeySpec getKey(String originKey) {
        // 根据给定的字节数组构造一个密钥
        SecretKeySpec key = new SecretKeySpec(originKey.getBytes(), "DES");
        return key;
    }

    /**
     * 不论originKey多长，我们都要形成一个8字节长度的演示密钥
     * 我们采用字节数组的填充，更多方法可以自己深入探究
     *
     * @param originKey
     * @return
     */
    private static SecretKeySpec getKeyLimitLength(String originKey) {
        // byte[]数组每个元素默认初始为0
        byte[] buffer = new byte[8];
        // 获取用户提供的原始密钥字节数组
        byte[] originBytes = originKey.getBytes();
        for (int i = 0; i < 8 && i < originBytes.length; i++) {
            buffer[i] = originBytes[i];
        }
        // 根据给定的字节数组构造一个密钥
        SecretKeySpec key = new SecretKeySpec(buffer, "DES");
        return key;
    }
}

```


### 3 . 为什么会出现乱码？

```
       +----------------+
        | clearText 明文 |
       +----------------+
                 |
                 |        <--- 编码（GBK）
                \|/
    +----------------------+
     | clearText.getBytes() |
    +----------------------+
                 |
                 |        <--- DES加密
                \|/
    +----------------------+
     | byte[] doFinal = ...   |
    +----------------------+
                 |
                 |        <--- 解码（GBK）XXXXX  -->为避免乱码，要修改为base64
                \|/
           +------+
            |  乱码  |
           +-------+
 ```

**原因**：将原来的byte[]加密转后之后，在编码表GBK或UTF-8上可能找不到对应的字符，那么就会造成字节丢失

**解决**：找一个编码表，编解码都能在码表上找到对应的内容。（base64）

**base64** : 总共64个字符  2的6次方

* 字符串为3的整数倍，依次取6位，拼成4个6位的二进制数，得到十进制数后查base64表对应的码
* %3，余数为2，依次取6位，拼成最小个数的6位的二进制数（不够的补0，这种情况下会补两个0），得到十进制数后查base64表对应的码，最后得到的字符要补足四位，补”=“（两个0补一个”=“）
* %3，余数为1，依次取6位，拼成最小个数的6位的二进制数（不够的补0，这种情况下会补四个0），得到十进制数后查base64表对应的码，最后得到的字符要补足四位，补”=“（四个0补两个个”=“）

最后的一个结果：通过base64编解码，所有的字节都不会丢失


需求：当用户输入任意长度的原始密钥，我们都可以进行加密

若我们不对密钥处理，将引发下面错误
>Exception in thread "main" java.security.InvalidKeyException: Wrong key size
	at com.sun.crypto.provider.DESCrypt.init(DESCrypt.java:536)
	at com.sun.crypto.provider.ElectronicCodeBook.init(ElectronicCodeBook.java:94)
	at com.sun.crypto.provider.CipherCore.init(CipherCore.java:591)
	at com.sun.crypto.provider.CipherCore.init(CipherCore.java:467)
	at com.sun.crypto.provider.DESCipher.engineInit(DESCipher.java:186)
	at javax.crypto.Cipher.implInit(Cipher.java:801)
	at javax.crypto.Cipher.chooseProvider(Cipher.java:863)
	at javax.crypto.Cipher.init(Cipher.java:1248)
	at javax.crypto.Cipher.init(Cipher.java:1185)
	at com.xiechong.encrypt.DesDemo.desEncrypt(DesDemo.java:41)
	at com.xiechong.encrypt.DesDemo.main(DesDemo.java:18)

我们需要对原始密钥进行长度限制，见方法 ```SecretKeySpec getKeyLimitLength(String originKey)```。



---
<h2 id="2.2">2.2 AES</h2>

---


**AesDemo.java**   
```
package com.xiechong.encrypt;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class AesDemo {
    public static void main(String[] args) throws Exception {
        String clearText = "heinma你好";
        String originKey = "123456789";
        String cipherText = desEncrypt(clearText, originKey);
        System.out.println(cipherText);
        String desDeCryptText = desDecrypt(cipherText, originKey);
        System.out.println(desDeCryptText);
    }

    private static String desDecrypt(String cipherText, String originKey) throws InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher = Cipher.getInstance("aes");
        SecretKeySpec key = getKeyLimitLength(originKey);
        cipher.init(Cipher.DECRYPT_MODE, key);

        byte[] deCode = Base64.getDecoder().decode(cipherText);
        byte[] doFinal = cipher.doFinal(deCode);

        return new String(doFinal);
    }


    private static String desEncrypt(String clearText, String originKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher = Cipher.getInstance("aes");
        SecretKeySpec key = getKeyLimitLength(originKey);
        cipher.init(Cipher.ENCRYPT_MODE, key);

        byte[] doFinal = cipher.doFinal(clearText.getBytes());

        // 使用base64来解决乱码问题
        byte[] base64StrEn = Base64.getEncoder().encode(doFinal);
        return new String(base64StrEn);
    }

    private static SecretKeySpec getKeyLimitLength(String originKey) {
        // byte[]数组每个元素默认初始为0
        byte[] buffer = new byte[32];// 16/24/32
        // 获取用户提供的原始密钥字节数组
        byte[] originBytes = originKey.getBytes();
        for (int i = 0; i < 8 && i < originBytes.length; i++) {
            buffer[i] = originBytes[i];
        }
        // 根据给定的字节数组构造一个密钥
        SecretKeySpec key = new SecretKeySpec(buffer, "aes");
        return key;
    }
}
```





---
<h1 id="13">3 | 非对称加密</h1>

---

---
<h2 id="3.1">3.1 RSA</h2>

---





